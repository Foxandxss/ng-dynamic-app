import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';

import { Observable } from 'rxjs/Observable';
import { AsyncSubject } from 'rxjs/AsyncSubject';
import { of } from 'rxjs/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';

// Interface is in separate file to make compiler happy
import { DocumentContents } from './document-contents';
export { DocumentContents } from './document-contents';

import { LocationService } from './location.service';

@Injectable()
export class DocumentService {

  /** Cache of observables of fetched docs, keyed by the doc's id (url) */
  private cache = new Map<string, Observable<DocumentContents>>();

  /** Observable of the current doc. Changes as we navigate. */
  currentDocument: Observable<DocumentContents>;

  constructor(
    private http: HttpClient,
    location: LocationService) {
    // Whenever the URL changes we try to get the corresponding doc
    this.currentDocument = location.currentPath.switchMap(
      path => this.getDocument(path)
    );
  }

  private getDocument(id: string): Observable<DocumentContents> {
    id = id || 'index';
    console.log(`getting document "${id}".`);
    if (!this.cache.has(id)) {
      this.cache.set(id, this.fetchDocument(id));
    }
    return this.cache.get(id);
  }

  private fetchDocument(id: string): Observable<DocumentContents> {
    const requestPath = `docs/${id}.html`;
    console.log(`fetching "${id}" document from "${requestPath}".`);

    // Observable subject that completes when the doc is retrieved.
    // https://github.com/ReactiveX/rxjs/blob/master/src/AsyncSubject.ts
    const docSubject = new AsyncSubject<DocumentContents>();

    this.http
      // In the real-world DocViewer, we get a JSON DocumentContents object
      // that was generated by a documentation build process.
      // .get<DocumentContents>(requestPath, {responseType: 'json'})

      // In this simpler example, we get the doc as HTML text
      // and map it into a fake DocumentContents object
      .get(requestPath, {responseType: 'text'})
      .map(contents => ({id, contents} as DocumentContents))
      .catch((error: HttpErrorResponse) => {
        return error.status === 404 ?
          this.getFileNotFoundDoc(id) :
          this.getErrorDoc(id, error);
      })
      .subscribe(docSubject);

      return docSubject.asObservable();
  }

  private getFileNotFoundDoc(id: string): Observable<DocumentContents> {
    console.error(`Document file not found at '${id}'`);
    // Leave this doc's observable in cache  because
    // assume if not found once, it will never be found.
    return of({
      id: 'doc-file-not-found',
      contents: `<h1 class="error">Document "${id}" not found.</h1>`
    });
  }

  private getErrorDoc(id: string, error: HttpErrorResponse): Observable<DocumentContents> {
    console.error('Error fetching document', error);
    // Remove this doc's observable from cache because
    // maybe this was a transient error and we can fetch it next time
    this.cache.delete(id);
    return of({
      id: 'doc-fetching-error',
      contents: `<h1 class="error">Error ${error} while fetching document "${id}".</h1>`
    });
  }
}
